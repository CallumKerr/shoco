#!/usr/bin/python3

from __future__ import print_function

import fileinput
import collections

TABLE_C = """#ifdef _SHOCO_INTERNAL
/*
This file was generated by 'generate_successor_table.py',
so don't edit this by hand. Also, do not include this file
anywhere. It is internal to 'shoco.c'. Include 'shoco.h'
if you want to use shoco in your project.
*/

static const char chrs[{chrs_count}] = {{
    {chrs}
}};

static const char successors[{chrs_count}][{successors_count}] = {{
    {successors}
}};

static const signed char chrs_reversed[256] = {{
    {chrs_reversed}
}};

static const signed char successors_reversed[{chrs_count}][{chrs_count}] = {{
    {successors_reversed}
}};

static const char bigrams[{bigrams_count}][2] = {{
    {bigrams}
}};

#endif
"""


def bigrams(sequence):
    sequence = iter(sequence)
    last = next(sequence)
    for item in sequence:
        yield last, item
        last = item


def format_int_line(items):
    return ", ".join(["{}".format(k) for k in items])


def escape(char):
    return r"\'" if char == "'" else char


def format_chr_line(items):
    return ", ".join(["'{}'".format(escape(k)) for k in items])


def format_bg_line(items):
    return ",\n    ".join(["{{'{}', '{}'}}".format(escape(a), escape(b)) for a, b in items])


def get_most_common(counter, max_):
    most_common = collections.OrderedDict()
    for bg, count in counter.most_common():
        a, b = bg
        most_common[a] = []
        if len(most_common) >= max_:
            return most_common

def fill_successors(counter, successors, max_):
    for bg, count in counter.most_common():
        a, b = bg

        if a not in successors:
            continue
        elif successors[a] is None:
            if b in successors:
                successors[a] = [b]
        elif len(successors[a]) < max_:
            if b in successors:
                successors[a].append(b)

        if sum(map(len, successors.values())) == len(successors) * max_:
            break

    if sum(map(len, successors.values())) < len(successors) * max_:
        import sys
        print("ERROR: Not enough successors found to fill the table.\n", file=sys.stderr)
        sys.exit(1)


def main():
    chars_count = 32
    bigrams_count = 64
    successors_count = 8

    bigram_counter = collections.Counter()
    bibigram_counter = collections.Counter()

    for line in fileinput.input():
        bgs = list(bigrams(line.strip()))
        for bg in bgs:
            bigram_counter[bg] += 1

        bbgs = list(bigrams(bgs))
        for bbg in bbgs:
            bibigram_counter[bbg] += 1

    # generate list of most common chars
    successors = get_most_common(bigram_counter, chars_count)
    bi_successors = get_most_common(bibigram_counter, bigrams_count)


    fill_successors(bigram_counter, successors, successors_count)
    #fill_successors(bibigram_counter, bi_successors, 1)

    chrs_formated = format_chr_line(successors.keys())
    bigrams_formated = format_bg_line(bi_successors.keys())

    successors_formated = ",\n    ".join(format_chr_line(l) for l in successors.values())
    chrs_indices = collections.OrderedDict(zip(successors.keys(), range(chars_count)))

    chrs_reversed = [chrs_indices.get(chr(i), -1) for i in range(256)]
    chrs_reversed_formated = format_int_line(chrs_reversed)
    successors_reversed = collections.OrderedDict()
    for char, successor_list in successors.items():
        successors_reversed[char] = [None] * chars_count
        s_indices = collections.OrderedDict(zip(successor_list, range(chars_count)))
        for i, s in enumerate(successors.keys()):
            successors_reversed[char][i] = s_indices.get(s, -1)

    successors_reversed_formated = ",\n    ".join(format_int_line(l) for l in successors_reversed.values())

    print(TABLE_C.format(
        chrs_count=chars_count,
        bigrams_count=bigrams_count,
        successors_count=successors_count,
        chrs=chrs_formated,
        successors=successors_formated,
        chrs_reversed=chrs_reversed_formated,
        successors_reversed=successors_reversed_formated,
        bigrams=bigrams_formated))

if __name__ == "__main__":
    main()
